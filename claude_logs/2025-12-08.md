# 作業ログ: 2025-12-08

## セッション概要
**目的**: 入園申込システムのバックエンドAPI実装(Phase 2)の継続と動作確認

**前回セッションからの継続内容**:
- Phase 1: ApplicationWorkテーブル作成、要件定義書・設計書更新 (完了)
- Phase 2: バックエンドAPI実装 (本セッションで完了)

---

## 実施内容

### 1. セッション開始時の状況確認

前回セッションで完了していた内容:
- ✅ ApplicationWorkテーブルSQL作成
- ✅ 要件定義書更新
- ✅ データベース設計書更新
- ✅ API設計書更新

本セッションの開始時タスク:
- Phase 2バックエンドAPI実装の継続

---

### 2. Phase 2 バックエンドAPI実装

#### 2.1 モデル実装

**ファイル**: `ReactApp.Server/Models/ApplicationWork.cs` (新規作成)

29フィールドを持つ入園申込ワークテーブルエンティティを実装:

```csharp
public class ApplicationWork
{
    [Key]
    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
    public int Id { get; set; }

    [Required]
    public int NurseryId { get; set; }

    // 申請保護者情報 (13フィールド)
    [Required]
    [StringLength(100)]
    public string ApplicantName { get; set; } = string.Empty;

    [Required]
    [StringLength(100)]
    public string ApplicantNameKana { get; set; } = string.Empty;

    [Required]
    public DateTime DateOfBirth { get; set; }

    [StringLength(8)]
    public string? PostalCode { get; set; }

    [StringLength(10)]
    public string? Prefecture { get; set; }

    [StringLength(50)]
    public string? City { get; set; }

    [StringLength(200)]
    public string? AddressLine { get; set; }

    [Required]
    [StringLength(20)]
    public string MobilePhone { get; set; } = string.Empty;

    [StringLength(20)]
    public string? HomePhone { get; set; }

    [StringLength(20)]
    public string? EmergencyContact { get; set; }

    [StringLength(255)]
    public string? Email { get; set; }

    [Required]
    [StringLength(20)]
    public string RelationshipToChild { get; set; } = string.Empty;

    // 園児情報 (7フィールド)
    [Required]
    [StringLength(100)]
    public string ChildName { get; set; } = string.Empty;

    [Required]
    [StringLength(100)]
    public string ChildNameKana { get; set; } = string.Empty;

    [Required]
    public DateTime ChildDateOfBirth { get; set; }

    [Required]
    [StringLength(2)]
    public string ChildGender { get; set; } = string.Empty;

    [StringLength(10)]
    public string? ChildBloodType { get; set; }

    [StringLength(1000)]
    public string? ChildMedicalNotes { get; set; }

    [StringLength(1000)]
    public string? ChildSpecialInstructions { get; set; }

    // 申込管理情報 (7フィールド)
    [Required]
    [StringLength(20)]
    public string ApplicationStatus { get; set; } = "Pending";

    [Required]
    public bool IsImported { get; set; } = false;

    public DateTime? ImportedAt { get; set; }

    public int? ImportedByUserId { get; set; }

    [Required]
    public DateTime CreatedAt { get; set; }

    public DateTime? UpdatedAt { get; set; }

    [StringLength(500)]
    public string? RejectionReason { get; set; }
}
```

**ファイル**: `ReactApp.Server/Models/Nursery.cs` (修正)

ApplicationKeyプロパティを追加:

```csharp
// Line 132追加
/// <summary>
/// 入園申込キー(任意、最大255文字)
/// 保護者向けWeb申込フォームのアクセスキー(UUID形式)
/// </summary>
[StringLength(255)]
public string? ApplicationKey { get; set; }
```

#### 2.2 DbContext更新

**ファイル**: `ReactApp.Server/Data/KindergartenDbContext.cs` (修正)

ApplicationWorkエンティティの登録と5つのインデックス設定:

```csharp
public DbSet<ApplicationWork> ApplicationWorks { get; set; }

private void ConfigureApplicationWork(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<ApplicationWork>(entity =>
    {
        entity.HasKey(e => e.Id);

        // 5つのインデックス作成
        entity.HasIndex(e => e.NurseryId)
            .HasDatabaseName("IX_ApplicationWork_NurseryId");

        entity.HasIndex(e => e.MobilePhone)
            .HasDatabaseName("IX_ApplicationWork_MobilePhone");

        entity.HasIndex(e => e.ApplicationStatus)
            .HasDatabaseName("IX_ApplicationWork_ApplicationStatus");

        entity.HasIndex(e => e.IsImported)
            .HasDatabaseName("IX_ApplicationWork_IsImported");

        entity.HasIndex(e => e.CreatedAt)
            .HasDatabaseName("IX_ApplicationWork_CreatedAt")
            .IsDescending(true);

        // カラム設定
        entity.Property(e => e.ApplicationStatus)
            .HasDefaultValue("Pending");

        entity.Property(e => e.IsImported)
            .HasDefaultValue(false);

        entity.Property(e => e.CreatedAt)
            .HasDefaultValueSql("GETUTCDATE()");
    });
}
```

#### 2.3 DTOs実装

**ファイル**: `ReactApp.Server/DTOs/Desktop/ApplicationWorkDto.cs` (新規作成)

8つのDTOクラスを定義:

1. **ApplicationWorkDto** - 申込詳細情報(29フィールド + 重複保護者情報)
2. **DuplicateParentInfo** - 重複保護者検出情報
3. **ApplicationListItemDto** - 申込一覧項目(6フィールド)
4. **CreateApplicationRequest** - 入園申込作成リクエスト
5. **ImportApplicationRequest** - 申込取込リクエスト
6. **ImportApplicationResult** - 申込取込結果
7. **RejectApplicationRequest** - 申込却下リクエスト
8. **ValidateApplicationKeyRequest/Result** - ApplicationKey検証

```csharp
// 重複保護者情報DTO
public class DuplicateParentInfo
{
    public bool HasDuplicate { get; set; }
    public int? ExistingParentId { get; set; }
    public string? ExistingParentName { get; set; }
    public int ChildCount { get; set; }
}

// 申込一覧項目DTO
public class ApplicationListItemDto
{
    public int Id { get; set; }
    public string ApplicantName { get; set; } = string.Empty;
    public string ChildName { get; set; } = string.Empty;
    public string MobilePhone { get; set; } = string.Empty;
    public string ApplicationStatus { get; set; } = "Pending";
    public DateTime CreatedAt { get; set; }
    public DateTime? ImportedAt { get; set; }
}

// 申込取込結果DTO
public class ImportApplicationResult
{
    public bool Success { get; set; }
    public int ParentId { get; set; }
    public int ChildId { get; set; }
    public bool IsNewParent { get; set; }
    public bool ParentOverwritten { get; set; }
    public string Message { get; set; } = string.Empty;
}
```

#### 2.4 サービス実装

**ファイル**: `ReactApp.Server/Services/IApplicationService.cs` (新規作成)

サービスインターフェース定義:

```csharp
public interface IApplicationService
{
    Task<ValidateApplicationKeyResult> ValidateApplicationKeyAsync(string applicationKey);
    Task<int> CreateApplicationAsync(CreateApplicationRequest request, string applicationKey);
    Task<PaginatedResult<ApplicationListItemDto>> GetApplicationListAsync(
        int nurseryId, string? status, DateTime? startDate, DateTime? endDate,
        int page, int pageSize);
    Task<ApplicationWorkDto?> GetApplicationDetailAsync(int id, int nurseryId);
    Task<ImportApplicationResult> ImportApplicationAsync(
        int id, int nurseryId, ImportApplicationRequest request, int userId);
    Task RejectApplicationAsync(int id, int nurseryId, RejectApplicationRequest request);
}
```

**ファイル**: `ReactApp.Server/Services/ApplicationService.cs` (新規作成)

ビジネスロジック実装 (主要メソッド):

1. **ValidateApplicationKeyAsync** - ApplicationKey検証
   - NurseryテーブルからApplicationKeyを検索
   - 一致する保育園情報を返却

2. **CreateApplicationAsync** - 入園申込作成
   - ApplicationKey検証
   - 電話番号の正規化(ハイフン削除)
   - ApplicationWorkテーブルへの挿入

3. **GetApplicationListAsync** - 申込一覧取得
   - ステータス、日付範囲でフィルタリング
   - ページネーション対応
   - CreatedAt降順でソート

4. **GetApplicationDetailAsync** - 申込詳細取得
   - ApplicationWork取得
   - **重複保護者検出**: 電話番号(正規化済み)で既存保護者を検索
   - 重複がある場合、保護者情報と既存の子供数を返却

5. **ImportApplicationAsync** - 申込取込(トランザクション処理)
   ```csharp
   public async Task<ImportApplicationResult> ImportApplicationAsync(...)
   {
       using var transaction = await _context.Database.BeginTransactionAsync();

       try
       {
           // 1. 申込の検証
           var application = await _context.ApplicationWorks
               .Where(a => a.Id == id && a.NurseryId == nurseryId)
               .FirstOrDefaultAsync();

           if (application == null)
               throw new InvalidOperationException("申込が見つかりません。");

           if (application.IsImported)
               throw new InvalidOperationException("既に取込済みの申込です。");

           // 2. 重複保護者チェック(電話番号正規化済み)
           var existingParent = await _context.Parents
               .Where(p => p.NurseryId == nurseryId &&
                          p.PhoneNumber == application.MobilePhone &&
                          p.IsActive)
               .FirstOrDefaultAsync();

           // 3. 保護者処理(更新 or 新規作成)
           int parentId;
           bool isNewParent;
           if (existingParent != null)
           {
               parentId = existingParent.Id;
               isNewParent = false;
               if (request.OverwriteParent)
               {
                   existingParent.Name = application.ApplicantName;
                   existingParent.Email = application.Email;
                   existingParent.UpdatedAt = DateTime.UtcNow;
               }
           }
           else
           {
               parentId = await GetNextParentIdAsync(nurseryId);
               isNewParent = true;
               var newParent = new Parent
               {
                   Id = parentId,
                   NurseryId = nurseryId,
                   Name = application.ApplicantName,
                   PhoneNumber = application.MobilePhone,
                   Email = application.Email,
                   IsActive = true,
                   CreatedAt = DateTime.UtcNow
               };
               _context.Parents.Add(newParent);
           }

           // 4. 園児作成(常に新規)
           var childId = await GetNextChildIdAsync(nurseryId);
           var newChild = new Child
           {
               Id = childId,
               NurseryId = nurseryId,
               Name = application.ChildName,
               NameKana = application.ChildNameKana,
               DateOfBirth = application.ChildDateOfBirth,
               Gender = application.ChildGender,
               BloodType = application.ChildBloodType,
               MedicalNotes = application.ChildMedicalNotes,
               SpecialInstructions = application.ChildSpecialInstructions,
               IsActive = true,
               CreatedAt = DateTime.UtcNow
           };
           _context.Children.Add(newChild);

           // 5. 保護者-園児関係作成
           var relationship = new ParentChildRelationship
           {
               ParentId = parentId,
               NurseryId = nurseryId,
               ChildId = childId,
               RelationshipType = application.RelationshipToChild,
               IsPrimaryContact = true,
               HasPickupPermission = true,
               CanReceiveEmergencyNotifications = true,
               CreatedAt = DateTime.UtcNow,
               IsActive = true
           };
           _context.ParentChildRelationships.Add(relationship);

           // 6. ApplicationWork更新
           application.ApplicationStatus = "Imported";
           application.IsImported = true;
           application.ImportedAt = DateTime.UtcNow;
           application.ImportedByUserId = userId;

           await _context.SaveChangesAsync();
           await transaction.CommitAsync();

           return new ImportApplicationResult
           {
               Success = true,
               ParentId = parentId,
               ChildId = childId,
               IsNewParent = isNewParent,
               ParentOverwritten = !isNewParent && request.OverwriteParent,
               Message = "申込を正常に取り込みました。"
           };
       }
       catch (Exception ex)
       {
           await transaction.RollbackAsync();
           throw;
       }
   }
   ```

6. **RejectApplicationAsync** - 申込却下
   - ApplicationStatus = "Rejected"に更新
   - RejectionReasonに却下理由を記録

#### 2.5 コントローラー実装

**ファイル**: `ReactApp.Server/Controllers/ApplicationController.cs` (新規作成)

公開API(認証不要):

```csharp
[ApiController]
[Route("api/application")]
[AllowAnonymous]
public class ApplicationController : ControllerBase
{
    private readonly IApplicationService _applicationService;

    [HttpPost("validate-key")]
    public async Task<IActionResult> ValidateKey([FromBody] ValidateApplicationKeyRequest request)
    {
        var result = await _applicationService.ValidateApplicationKeyAsync(request.ApplicationKey);

        if (result.IsValid)
        {
            return Ok(new ApiResponse<ValidateApplicationKeyResult>
            {
                Success = true,
                Data = result
            });
        }

        return BadRequest(new ApiResponse<ValidateApplicationKeyResult>
        {
            Success = false,
            Error = new ApiError
            {
                Code = "INVALID_APPLICATION_KEY",
                Message = "無効な申込キーです。"
            }
        });
    }

    [HttpPost("submit")]
    [EnableRateLimiting("application-submit")]
    public async Task<IActionResult> Submit(
        [FromBody] CreateApplicationRequest request,
        [FromQuery] string key)
    {
        var applicationId = await _applicationService.CreateApplicationAsync(request, key);

        return Created($"/api/application/{applicationId}", new ApiResponse<object>
        {
            Success = true,
            Data = new { ApplicationId = applicationId }
        });
    }
}

// ファイルスコープクラス(名前空間汚染防止)
file class ApiResponse<T>
{
    public bool Success { get; set; }
    public T? Data { get; set; }
    public ApiError? Error { get; set; }
}

file class ApiError
{
    public string Code { get; set; } = string.Empty;
    public string Message { get; set; } = string.Empty;
    public List<string>? Details { get; set; }
}
```

**ファイル**: `ReactApp.Server/Controllers/DesktopApplicationController.cs` (新規作成)

デスクトップAPI(JWT認証必須):

```csharp
[ApiController]
[Route("api/desktop/application")]
[Authorize]
public class DesktopApplicationController : ControllerBase
{
    private readonly IApplicationService _applicationService;

    [HttpGet]
    public async Task<IActionResult> GetList(
        [FromQuery] string? status,
        [FromQuery] DateTime? startDate,
        [FromQuery] DateTime? endDate,
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 20)
    {
        var nurseryId = GetNurseryId();
        var result = await _applicationService.GetApplicationListAsync(
            nurseryId, status, startDate, endDate, page, pageSize);

        return Ok(new ApiResponse<PaginatedResult<ApplicationListItemDto>>
        {
            Success = true,
            Data = result
        });
    }

    [HttpGet("{id}")]
    public async Task<IActionResult> GetDetail(int id)
    {
        var nurseryId = GetNurseryId();
        var result = await _applicationService.GetApplicationDetailAsync(id, nurseryId);

        if (result == null)
        {
            return NotFound(new ApiResponse<ApplicationWorkDto>
            {
                Success = false,
                Error = new ApiError
                {
                    Code = "NOT_FOUND",
                    Message = "申込が見つかりません。"
                }
            });
        }

        return Ok(new ApiResponse<ApplicationWorkDto>
        {
            Success = true,
            Data = result
        });
    }

    [HttpPost("{id}/import")]
    public async Task<IActionResult> Import(int id, [FromBody] ImportApplicationRequest request)
    {
        var nurseryId = GetNurseryId();
        var userId = GetUserId();

        var result = await _applicationService.ImportApplicationAsync(id, nurseryId, request, userId);

        return Ok(new ApiResponse<ImportApplicationResult>
        {
            Success = true,
            Data = result
        });
    }

    [HttpPost("{id}/reject")]
    public async Task<IActionResult> Reject(int id, [FromBody] RejectApplicationRequest request)
    {
        var nurseryId = GetNurseryId();
        await _applicationService.RejectApplicationAsync(id, nurseryId, request);

        return Ok(new ApiResponse<object>
        {
            Success = true,
            Data = new { Message = "申込を却下しました。" }
        });
    }

    private int GetNurseryId()
    {
        var claim = User.FindFirst("NurseryId");
        if (claim == null || !int.TryParse(claim.Value, out var nurseryId))
        {
            throw new UnauthorizedAccessException("NurseryId claim not found");
        }
        return nurseryId;
    }

    private int GetUserId()
    {
        var claim = User.FindFirst("UserId");
        if (claim == null || !int.TryParse(claim.Value, out var userId))
        {
            throw new UnauthorizedAccessException("UserId claim not found");
        }
        return userId;
    }
}

// ファイルスコープクラス
file class ApiResponse<T> { /* ... */ }
file class ApiError { /* ... */ }
```

#### 2.6 DI登録とRate Limiting設定

**ファイル**: `ReactApp.Server/Program.cs`

Line 273: DI登録
```csharp
builder.Services.AddScoped<IApplicationService, ApplicationService>();
```

Lines 208-215: Rate Limiting設定
```csharp
options.AddFixedWindowLimiter("application-submit", config =>
{
    config.PermitLimit = 10;
    config.Window = TimeSpan.FromHours(1);
    config.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;
    config.QueueLimit = 2;
});
```

---

### 3. ビルドエラー修正

#### 3.1 発生したエラー(5件)

実行コマンド:
```bash
cd ReactApp.Server && dotnet build
```

エラー内容:
1. **ApiResponse/ApiError重複定義** (2件)
   - ApplicationController.csとDesktopAuthController.csで同じ名前空間に定義
   - エラーメッセージ: `error CS0101: 名前空間 'ReactApp.Server.Controllers' は既に 'ApiResponse' の定義を含んでいます`

2. **PagedResult型が見つからない** (2件)
   - 既存コードベースは`PaginatedResult<T>`を使用
   - エラーメッセージ: `error CS0246: 型または名前空間の名前 'PagedResult<>' が見つかりませんでした`

3. **ParentChildRelationship.Relationship不在** (1件)
   - 正しいプロパティ名は`RelationshipType`
   - エラーメッセージ: `error CS0117: 'ParentChildRelationship' に 'Relationship' の定義がありません`

#### 3.2 修正内容

**修正1**: ApiResponse/ApiErrorの重複解消

ApplicationController.cs と DesktopApplicationController.cs:
```csharp
// public class → file class に変更(C# 11 ファイルスコープクラス)
file class ApiResponse<T>
{
    public bool Success { get; set; }
    public T? Data { get; set; }
    public ApiError? Error { get; set; }
}

file class ApiError
{
    public string Code { get; set; } = string.Empty;
    public string Message { get; set; } = string.Empty;
    public List<string>? Details { get; set; }
}
```

**修正2**: PagedResult → PaginatedResult

IApplicationService.cs:
```csharp
// 修正前
Task<PagedResult<ApplicationListItemDto>> GetApplicationListAsync(...)

// 修正後
Task<PaginatedResult<ApplicationListItemDto>> GetApplicationListAsync(...)
```

ApplicationService.cs:
```csharp
// 修正前
public async Task<PagedResult<ApplicationListItemDto>> GetApplicationListAsync(...)
{
    return new PagedResult<ApplicationListItemDto>
    {
        Items = applications,
        TotalItems = totalItems,
        Page = page,
        PageSize = pageSize
    };
}

// 修正後
public async Task<PaginatedResult<ApplicationListItemDto>> GetApplicationListAsync(...)
{
    return new PaginatedResult<ApplicationListItemDto>
    {
        Items = applications,
        TotalCount = totalItems,
        CurrentPage = page,
        PageSize = pageSize
    };
}
```

DesktopApplicationController.cs:
```csharp
// using追加
using ReactApp.Server.DTOs;

// 戻り値の型変更
ApiResponse<PaginatedResult<ApplicationListItemDto>>
```

**修正3**: Relationship → RelationshipType

ApplicationService.cs (Line 355):
```csharp
// 修正前
var relationship = new ParentChildRelationship
{
    ParentId = parentId,
    NurseryId = nurseryId,
    ChildId = childId,
    Relationship = application.RelationshipToChild,  // ❌
    CreatedAt = DateTime.UtcNow
};

// 修正後
var relationship = new ParentChildRelationship
{
    ParentId = parentId,
    NurseryId = nurseryId,
    ChildId = childId,
    RelationshipType = application.RelationshipToChild,  // ✅
    CreatedAt = DateTime.UtcNow,
    IsActive = true
};
```

**ビルド結果**:
```bash
cd ReactApp.Server && dotnet build
# 出力: ビルドに成功しました。
```

---

### 4. データベースマイグレーション対応

#### 4.1 Nursery.ApplicationKey追加マイグレーション

作成コマンド:
```bash
cd ReactApp.Server && dotnet ef migrations add AddApplicationKeyToNursery
```

問題点:
- マイグレーションファイルに不要な変更が含まれていた
  - ChildClassAssignments.Notes列の削除
  - AcademicYears.StartDate/EndDate型変更

対処:
1. マイグレーションファイルを手動編集し、不要な変更を削除
2. `dotnet ef database update`実行時にエラー発生
   - ApplicationKey列が既に存在していた(前回セッションで作成済み)
3. マイグレーションを削除: `dotnet ef migrations remove`

#### 4.2 ApplicationWorkテーブル作成

**ファイル**: `ReactApp.Server/scripts/create_application_work_table.sql` (作成)

```sql
-- 入園申込ワークテーブル作成スクリプト
IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = 'ApplicationWorks')
BEGIN
    CREATE TABLE [dbo].[ApplicationWorks] (
        [Id] INT IDENTITY(1,1) NOT NULL,
        [NurseryId] INT NOT NULL,

        -- 申請保護者情報 (13フィールド)
        [ApplicantName] NVARCHAR(100) NOT NULL,
        [ApplicantNameKana] NVARCHAR(100) NOT NULL,
        [DateOfBirth] DATETIME2 NOT NULL,
        [PostalCode] NVARCHAR(8) NULL,
        [Prefecture] NVARCHAR(10) NULL,
        [City] NVARCHAR(50) NULL,
        [AddressLine] NVARCHAR(200) NULL,
        [MobilePhone] NVARCHAR(20) NOT NULL,
        [HomePhone] NVARCHAR(20) NULL,
        [EmergencyContact] NVARCHAR(20) NULL,
        [Email] NVARCHAR(255) NULL,
        [RelationshipToChild] NVARCHAR(20) NOT NULL,

        -- 園児情報 (7フィールド)
        [ChildName] NVARCHAR(100) NOT NULL,
        [ChildNameKana] NVARCHAR(100) NOT NULL,
        [ChildDateOfBirth] DATETIME2 NOT NULL,
        [ChildGender] NVARCHAR(2) NOT NULL,
        [ChildBloodType] NVARCHAR(10) NULL,
        [ChildMedicalNotes] NVARCHAR(1000) NULL,
        [ChildSpecialInstructions] NVARCHAR(1000) NULL,

        -- 申込管理情報 (7フィールド)
        [ApplicationStatus] NVARCHAR(20) NOT NULL DEFAULT 'Pending',
        [IsImported] BIT NOT NULL DEFAULT 0,
        [ImportedAt] DATETIME2 NULL,
        [ImportedByUserId] INT NULL,
        [CreatedAt] DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
        [UpdatedAt] DATETIME2 NULL,
        [RejectionReason] NVARCHAR(500) NULL,

        CONSTRAINT [PK_ApplicationWorks] PRIMARY KEY CLUSTERED ([Id] ASC)
    );

    -- 5つのインデックス作成
    CREATE NONCLUSTERED INDEX [IX_ApplicationWork_NurseryId]
        ON [dbo].[ApplicationWorks]([NurseryId] ASC);

    CREATE NONCLUSTERED INDEX [IX_ApplicationWork_MobilePhone]
        ON [dbo].[ApplicationWorks]([MobilePhone] ASC);

    CREATE NONCLUSTERED INDEX [IX_ApplicationWork_ApplicationStatus]
        ON [dbo].[ApplicationWorks]([ApplicationStatus] ASC);

    CREATE NONCLUSTERED INDEX [IX_ApplicationWork_IsImported]
        ON [dbo].[ApplicationWorks]([IsImported] ASC);

    CREATE NONCLUSTERED INDEX [IX_ApplicationWork_CreatedAt]
        ON [dbo].[ApplicationWorks]([CreatedAt] DESC);

    PRINT 'ApplicationWorksテーブルを作成しました。';
END
ELSE
BEGIN
    PRINT 'ApplicationWorksテーブルは既に存在します。';
END
GO
```

注記: ユーザーが手動でテーブルを作成済みとのこと

---

### 5. API動作確認

#### 5.1 サーバー起動

```bash
cd ReactApp.Server && dotnet run --no-build &
```

起動確認:
```
[21:09:41 INF] Now listening on: http://localhost:5131
[21:09:41 INF] Application started. Press Ctrl+C to shut down.
```

#### 5.2 基本APIテスト

**ファイル**: `test_application_api.sh` (作成)

テストスクリプト内容:
```bash
#!/bin/bash
BASE_URL="http://localhost:5131/api"
DESKTOP_BASE_URL="http://localhost:5131/api/desktop"

# 1. ApplicationKey検証テスト (無効なキー)
curl -X POST "${BASE_URL}/application/validate-key" \
  -H "Content-Type: application/json" \
  -d '{"applicationKey":"invalid-key-12345"}' \
  -w "\nHTTP Status: %{http_code}\n\n"

# 2. 入園申込送信テスト (ApplicationKeyなし)
curl -X POST "${BASE_URL}/application/submit" \
  -H "Content-Type: application/json" \
  -d '{...}' \
  -w "\nHTTP Status: %{http_code}\n\n"

# 3. デスクトップAPI - 申込一覧取得 (認証なし)
curl -X GET "${DESKTOP_BASE_URL}/application" \
  -H "Content-Type: application/json" \
  -w "\nHTTP Status: %{http_code}\n\n"
```

#### 5.3 テスト結果

**テスト1**: POST /api/application/validate-key (無効なキー)
- HTTPステータス: **400 Bad Request** ✅
- レスポンス:
  ```json
  {
    "success": false,
    "error": {
      "code": "INVALID_APPLICATION_KEY",
      "message": "無効な申込キーです。"
    }
  }
  ```
- 結果: **正常動作**

**テスト2**: POST /api/application/submit (ApplicationKeyなし)
- HTTPステータス: **400 Bad Request** ✅
- レスポンス: バリデーションエラー
  ```json
  {
    "type": "https://tools.ietf.org/html/rfc9110#section-15.5.1",
    "title": "One or more validation errors occurred.",
    "status": 400,
    "errors": {
      "key": ["The key field is required."],
      "request": ["The request field is required."],
      ...
    }
  }
  ```
- 結果: **正常動作** (必須フィールドバリデーション)

**テスト3**: GET /api/desktop/application (認証なし)
- HTTPステータス: **401 Unauthorized** ✅
- レスポンス: 空
- 結果: **正常動作** (JWT認証必須)

---

### 6. ドキュメント作成

#### 6.1 API動作確認レポート

**ファイル**: `test_api_complete.md` (作成)

内容:
- 実装内容まとめ(モデル、DTO、サービス、コントローラー、設定)
- テスト結果詳細
- 次のステップ(Phase 2-3完全動作確認、Phase 3/4実装)
- ファイルパスリンク付き

---

## 成果物

### 新規作成ファイル (9件)

1. `ReactApp.Server/Models/ApplicationWork.cs` - ApplicationWorkエンティティ
2. `ReactApp.Server/DTOs/Desktop/ApplicationWorkDto.cs` - 8つのDTOクラス
3. `ReactApp.Server/Services/IApplicationService.cs` - サービスインターフェース
4. `ReactApp.Server/Services/ApplicationService.cs` - サービス実装
5. `ReactApp.Server/Controllers/ApplicationController.cs` - 公開API
6. `ReactApp.Server/Controllers/DesktopApplicationController.cs` - デスクトップAPI
7. `ReactApp.Server/scripts/create_application_work_table.sql` - テーブル作成SQL
8. `test_application_api.sh` - APIテストスクリプト
9. `test_api_complete.md` - 動作確認レポート

### 修正ファイル (3件)

1. `ReactApp.Server/Models/Nursery.cs` - ApplicationKeyプロパティ追加
2. `ReactApp.Server/Data/KindergartenDbContext.cs` - ApplicationWork設定追加
3. `ReactApp.Server/Program.cs` - DI登録、Rate Limiting設定

---

## 技術的なポイント

### 1. トランザクション処理
ImportApplicationAsyncメソッドでは、以下を1つのトランザクションで処理:
- 保護者の作成or更新
- 園児の作成
- 保護者-園児関係の作成
- ApplicationWorkのステータス更新

エラー時は自動的にロールバックされ、データの整合性を保証

### 2. 重複保護者検出
電話番号を正規化(ハイフン削除)してから検索:
```csharp
var normalizedPhone = Regex.Replace(phoneNumber, @"[-\s]", "");
var existingParent = await _context.Parents
    .Where(p => p.NurseryId == nurseryId &&
                p.PhoneNumber == normalizedPhone &&
                p.IsActive)
    .FirstOrDefaultAsync();
```

### 3. ID生成戦略
保育園ごとにMAX+1でIDを採番:
```csharp
private async Task<int> GetNextParentIdAsync(int nurseryId)
{
    var maxId = await _context.Parents
        .Where(p => p.NurseryId == nurseryId)
        .Select(p => (int?)p.Id)
        .MaxAsync();
    return (maxId ?? 0) + 1;
}
```

### 4. ファイルスコープクラス(C# 11)
名前空間汚染を防ぐため、ApiResponse/ApiErrorを各コントローラーでfile classとして定義:
```csharp
file class ApiResponse<T> { /* ... */ }
file class ApiError { /* ... */ }
```

### 5. Rate Limiting
入園申込送信APIに対して時間当たり10件の制限を設定:
```csharp
[EnableRateLimiting("application-submit")]
public async Task<IActionResult> Submit(...)
```

---

## 残課題と次のステップ

### Phase 2完了項目
- ✅ ApplicationWorkモデル実装
- ✅ DTOs定義(8クラス)
- ✅ サービス実装(6メソッド)
- ✅ コントローラー実装(公開API + デスクトップAPI)
- ✅ DI登録、Rate Limiting設定
- ✅ ビルド成功
- ✅ 基本API動作確認

### Phase 2-3: 完全な動作確認 (未実施)

推奨される詳細テストシナリオ:

1. **有効なApplicationKeyでの申込送信**
   - NurseryテーブルにApplicationKey設定
   - 有効なキーでvalidate-key API呼び出し
   - 有効なキーでsubmit API呼び出し
   - ApplicationWorksテーブルへのデータ挿入確認

2. **デスクトップアプリ - 申込一覧取得**
   - JWT認証トークン取得(/api/desktop/auth/loginなど)
   - 申込一覧API呼び出し(認証ヘッダー付き)
   - ページネーション動作確認(page=1&pageSize=20)
   - フィルター機能確認(status, startDate, endDate)

3. **申込詳細取得 + 重複保護者検出**
   - 既存保護者と同じ電話番号で申込データ作成
   - 申込詳細API呼び出し
   - DuplicateParentInfoが正しく返されることを確認
   - ExistingParentId, ExistingParentName, ChildCountの値確認

4. **申込取込 - 新規保護者パターン**
   - 新しい電話番号で申込
   - import API呼び出し(OverwriteParent=false)
   - Parents, Children, ParentChildRelationshipsテーブルへの挿入確認
   - ApplicationWork.IsImported=true, ApplicationStatus="Imported"確認
   - ImportApplicationResult.IsNewParent=trueの確認

5. **申込取込 - 既存保護者(上書きON)パターン**
   - 既存保護者と同じ電話番号で申込
   - import API呼び出し(OverwriteParent=true)
   - 保護者情報の更新確認(Name, Email)
   - 新しい園児が作成されることを確認
   - ImportApplicationResult.ParentOverwritten=trueの確認

6. **申込取込 - 既存保護者(上書きOFF)パターン**
   - 既存保護者と同じ電話番号で申込
   - import API呼び出し(OverwriteParent=false)
   - 保護者情報が更新されないことを確認
   - 新しい園児が作成されることを確認
   - ImportApplicationResult.IsNewParent=false, ParentOverwritten=falseの確認

7. **申込却下**
   - reject API呼び出し(RejectionReason付き)
   - ApplicationWork.ApplicationStatus="Rejected"確認
   - ApplicationWork.RejectionReasonに値が設定されることを確認

8. **エラーケース**
   - 既に取込済みの申込を再度取込(エラー期待)
   - 存在しない申込IDで取込(エラー期待)
   - 他の保育園の申込を取込(エラー期待)

9. **Rate Limiting確認**
   - 1時間以内に11回の申込送信
   - 11回目で429 Too Many Requestsが返されることを確認

### Phase 3: 保護者向けWeb申込フォーム (未着手)

実装項目:
- React + TypeScriptでの申込フォーム画面
- ApplicationKey入力→保育園名表示
- 申請保護者情報入力(13フィールド)
- 園児情報入力(7フィールド)
- バリデーション
- 送信確認ダイアログ
- 送信完了画面

### Phase 4: デスクトップアプリ申込管理画面 (未着手)

実装項目:
- 申込一覧画面(フィルター、ページネーション)
- 申込詳細画面(重複保護者表示)
- 取込確認ダイアログ(上書き設定)
- 取込完了メッセージ
- 却下ダイアログ

---

## 所要時間
約2時間

---

## 備考

### ビルドエラー修正について
- 既存コードベースとの整合性確認の重要性
  - PaginatedResult vs PagedResult
  - RelationshipType vs Relationship
- C# 11のfile classキーワードが名前空間汚染防止に有効

### データベース設計について
- 電話番号の正規化が重複検出に重要
- トランザクション処理でデータ整合性を保証
- MAX+1 ID生成戦略(保育園スコープ内)

### API設計について
- 公開API(認証なし)とデスクトップAPI(JWT認証)の明確な分離
- Rate Limitingによる不正利用防止
- ページネーションによる大量データ対応
- file classによるDTO再利用とスコープ管理

---

## 参考リンク

### 実装ファイル
- [ApplicationWork.cs](ReactApp.Server/Models/ApplicationWork.cs:1)
- [ApplicationWorkDto.cs](ReactApp.Server/DTOs/Desktop/ApplicationWorkDto.cs:1)
- [ApplicationService.cs](ReactApp.Server/Services/ApplicationService.cs:1)
- [ApplicationController.cs](ReactApp.Server/Controllers/ApplicationController.cs:1)
- [DesktopApplicationController.cs](ReactApp.Server/Controllers/DesktopApplicationController.cs:1)

### ドキュメント
- [API動作確認レポート](test_api_complete.md:1)
- [テーブル作成SQL](ReactApp.Server/scripts/create_application_work_table.sql:1)

---

以上、2025-12-08の作業内容を記録しました。
